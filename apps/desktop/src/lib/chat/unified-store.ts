/**
 * Unified Chat Store
 *
 * Combines normalized message storage, part storage, and event coalescing
 * into a single cohesive store that follows OpenCode's architecture.
 *
 * Key features:
 * - Normalized storage: messages.byId + parts.byId
 * - Server-driven: All IDs generated by server (UUIDv7)
 * - Part-level updates: Update individual parts without full message re-renders
 * - Event coalescing: Batch updates per animation frame for smooth streaming
 * - Share-style updates: Replace parts by ID, no duplication
 *
 * Usage:
 * ```typescript
 * const store = createUnifiedChatStore();
 *
 * // Server sends events during streaming
 * store.events.queue({ type: "part.created", part: textPart });
 * store.events.queue({ type: "part.updated", part: updatedPart, delta: "token" });
 *
 * // Events are automatically coalesced and applied
 * ```
 */

import { createStore, produce } from "solid-js/store";
import type { Part, PartType } from "../../types/part";
import type { ChatMessageMetadata, ChatStatus, RLMStateData } from "../../types/ui-message";
import { createLogger } from "../logger";
import { createEventCoalescer, type CoalescedBatch } from "./event-coalescer";
import { createPartStore } from "./part-store";

const logger = createLogger("desktop:unified-store");

/**
 * Message metadata (minimal, parts stored separately)
 */
export interface Message {
  id: string;
  role: "user" | "assistant" | "system";
  sessionId: string;
  createdAt: number;
  updatedAt?: number;
  metadata?: ChatMessageMetadata;
}

/**
 * Unified chat store state
 */
export interface UnifiedChatState {
  /** Normalized message storage */
  messages: {
    byId: Record<string, Message>;
    order: string[];
  };
  /** Session state */
  session: {
    id: string | undefined;
    status: ChatStatus;
    error: Error | undefined;
  };
  /** RLM state (extracted for easy access) */
  rlmState: RLMStateData | null;
  /** Current metadata */
  currentMetadata: ChatMessageMetadata | null;
  /** UI preferences */
  ui: {
    showReasoning: boolean;
    compactMode: boolean;
  };
}

/**
 * Options for unified chat store
 */
export interface UnifiedChatStoreOptions {
  /** Initial messages */
  initialMessages?: Message[];
  /** Initial session ID */
  initialSessionId?: string;
  /** Called when state changes */
  onStateChange?: (state: UnifiedChatState) => void;
}

/**
 * Create a unified chat store
 */
export function createUnifiedChatStore(options: UnifiedChatStoreOptions = {}) {
  const { initialMessages = [], initialSessionId, onStateChange } = options;

  // Create part store
  const partStore = createPartStore();

  // Create main state store
  const [state, setState] = createStore<UnifiedChatState>({
    messages: {
      byId: Object.fromEntries(initialMessages.map(m => [m.id, m])),
      order: initialMessages.map(m => m.id),
    },
    session: {
      id: initialSessionId || undefined,
      status: "idle",
      error: undefined,
    },
    rlmState: null,
    currentMetadata: null,
    ui: {
      showReasoning: true,
      compactMode: false,
    },
  });

  /**
   * Apply a coalesced batch to the store
   */
  const applyBatch = (batch: CoalescedBatch): void => {
    // Apply message updates
    for (const [id, message] of batch.messages) {
      if (state.messages.byId[id]) {
        // Update existing
        setState(
          "messages",
          "byId",
          id,
          produce((m: Message) => {
            Object.assign(m, message);
            m.updatedAt = Date.now();
          })
        );
      } else {
        // Create new
        const newMessage: Message = {
          id: message.id,
          role: (message.role as Message["role"]) || "assistant",
          sessionId: message.sessionId || "",
          createdAt: message.createdAt || Date.now(),
          metadata: message.metadata as ChatMessageMetadata | undefined,
        };
        setState("messages", "byId", id, newMessage);
        setState("messages", "order", order => [...order, id]);
      }
    }

    // Apply message removals
    for (const messageId of batch.removedMessages) {
      setState(
        "messages",
        produce(draft => {
          delete draft.byId[messageId];
          draft.order = draft.order.filter(id => id !== messageId);
        })
      );
      // Also remove all parts for this message
      partStore.removePartsForMessage(messageId);
    }

    // Apply part updates
    for (const [id, part] of batch.parts) {
      if (partStore.hasPart(id)) {
        partStore.updatePart(id, { content: part.content, updatedAt: Date.now() });
      } else {
        partStore.addPart(part);
      }
    }

    // Apply accumulated deltas
    for (const [partId, delta] of batch.deltas) {
      partStore.updatePartWithDelta(partId, delta);
    }

    // Apply part removals
    for (const partId of batch.removedParts) {
      partStore.removePart(partId);
    }

    // Notify state change
    onStateChange?.(state);
  };

  // Create event coalescer
  const eventCoalescer = createEventCoalescer({
    onBatch: applyBatch,
    batchWindowMs: 16, // 60fps
    maxBatchSize: 100,
  });

  // ============================================================================
  // Message Operations
  // ============================================================================

  /**
   * Add a message
   */
  const addMessage = (message: Omit<Message, "createdAt"> & { createdAt?: number }): void => {
    const fullMessage: Message = {
      ...message,
      createdAt: message.createdAt || Date.now(),
    };

    eventCoalescer.queue({
      type: "message.created",
      message: fullMessage,
    });

    logger.debug("Message queued", { messageId: message.id, role: message.role });
  };

  /**
   * Update message metadata
   */
  const updateMessageMetadata = (messageId: string, metadata: ChatMessageMetadata): void => {
    eventCoalescer.queue({
      type: "message.updated",
      message: { id: messageId, metadata: metadata as unknown as Record<string, unknown> },
    });
  };

  /**
   * Remove a message
   */
  const removeMessage = (messageId: string): void => {
    eventCoalescer.queue({
      type: "message.removed",
      messageId,
    });
  };

  /**
   * Get a message by ID
   */
  const getMessage = (messageId: string): Message | undefined => {
    return state.messages.byId[messageId];
  };

  /**
   * Get all messages as array
   */
  const getMessages = (): Message[] => {
    return state.messages.order
      .map(id => state.messages.byId[id])
      .filter((m): m is Message => m !== undefined);
  };

  /**
   * Get messages with their parts
   */
  const getMessagesWithParts = (): Array<{ message: Message; parts: Part[] }> => {
    return getMessages().map(message => ({
      message,
      parts: partStore.getPartsForMessage(message.id),
    }));
  };

  // ============================================================================
  // Part Operations
  // ============================================================================

  /**
   * Add a part
   */
  const addPart = (part: Part): void => {
    eventCoalescer.queue({ type: "part.created", part });
  };

  /**
   * Update a part
   */
  const updatePart = (part: Part, delta?: string): void => {
    eventCoalescer.queue({ type: "part.updated", part, delta });
  };

  /**
   * Remove a part
   */
  const removePart = (partId: string, messageId: string): void => {
    eventCoalescer.queue({ type: "part.removed", partId, messageId });
  };

  /**
   * Get parts for a message
   */
  const getPartsForMessage = (messageId: string): Part[] => {
    return partStore.getPartsForMessage(messageId);
  };

  /**
   * Get parts by type
   */
  const getPartsByType = <T extends PartType>(
    messageId: string,
    type: T
  ): Extract<Part, { type: T }>[] => {
    return partStore.getPartsByType(messageId, type);
  };

  // ============================================================================
  // Session Operations
  // ============================================================================

  /**
   * Set session ID
   */
  const setSessionId = (id: string | null): void => {
    setState("session", "id", id === null ? undefined : id);
    logger.info("Session ID set", { sessionId: id ?? undefined });
  };

  /**
   * Set session status
   */
  const setStatus = (status: ChatStatus): void => {
    setState("session", "status", status);
    logger.debug("Status changed", { status });
  };

  /**
   * Set session error
   */
  const setError = (error: Error | null): void => {
    setState("session", "error", error === null ? undefined : error);
    if (error) {
      logger.error("Session error", error);
    }
  };

  // ============================================================================
  // RLM State Operations
  // ============================================================================

  /**
   * Set RLM state
   */
  const setRLMState = (rlmState: RLMStateData | null): void => {
    setState("rlmState", rlmState);
    logger.debug("RLM state updated", { phase: rlmState?.phase });
  };

  /**
   * Set current metadata
   */
  const setCurrentMetadata = (metadata: ChatMessageMetadata | null): void => {
    setState("currentMetadata", metadata);
    logger.debug("Metadata updated", { mode: metadata?.mode });
  };

  // ============================================================================
  // UI Operations
  // ============================================================================

  /**
   * Toggle reasoning visibility
   */
  const toggleReasoning = (): void => {
    setState("ui", "showReasoning", v => !v);
  };

  /**
   * Toggle compact mode
   */
  const toggleCompactMode = (): void => {
    setState("ui", "compactMode", v => !v);
  };

  // ============================================================================
  // Bulk Operations
  // ============================================================================

  /**
   * Clear all messages and parts
   */
  const clear = (): void => {
    setState("messages", { byId: {}, order: [] });
    partStore.clear();
    eventCoalescer.clear();
    logger.info("Store cleared");
  };

  /**
   * Flush pending events
   */
  const flush = (): void => {
    eventCoalescer.flush();
  };

  /**
   * Check if there are pending events
   */
  const hasPending = (): boolean => {
    return eventCoalescer.hasPending();
  };

  // ============================================================================
  // Hydration
  // ============================================================================

  /**
   * Hydrate store with session data
   */
  const hydrate = (data: { sessionId: string; messages: Message[]; parts: Part[] }): void => {
    // Clear existing
    clear();

    // Set session
    setSessionId(data.sessionId);

    // Add messages
    for (const message of data.messages) {
      setState("messages", "byId", message.id, message);
      setState("messages", "order", order => [...order, message.id]);
    }

    // Add parts
    partStore.importParts(data.parts);

    logger.info("Store hydrated", {
      sessionId: data.sessionId,
      messageCount: data.messages.length,
      partCount: data.parts.length,
    });
  };

  return {
    // State (reactive)
    get state() {
      return state;
    },

    // Part store (for direct access)
    parts: partStore,

    // Event coalescer (for direct access)
    events: eventCoalescer,

    // Message operations
    addMessage,
    updateMessageMetadata,
    removeMessage,
    getMessage,
    getMessages,
    getMessagesWithParts,

    // Part operations
    addPart,
    updatePart,
    removePart,
    getPartsForMessage,
    getPartsByType,

    // Session operations
    setSessionId,
    setStatus,
    setError,

    // RLM operations
    setRLMState,
    setCurrentMetadata,

    // UI operations
    toggleReasoning,
    toggleCompactMode,

    // Bulk operations
    clear,
    flush,
    hasPending,

    // Hydration
    hydrate,
  };
}

/**
 * Type for the unified chat store return value
 */
export type UnifiedChatStore = ReturnType<typeof createUnifiedChatStore>;
